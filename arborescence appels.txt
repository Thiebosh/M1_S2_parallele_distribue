-> synchronize_directory(self, frequency)

    -> self.search_updates(self.root_directory)
        for path_file, dirs, files in os.walk(directory):
            for dir_name in dirs:
                if self.is_superior_max_depth(folder_path) is False:
                     if folder_path not in self.synchronize_dict.keys():
                         if not self.ftp.if_exist(srv_full_path, self.ftp.get_folder_content(directory_split)):
                            => self.ftp.create_folder(srv_full_path) # final
            for file_name in files:
                if self.is_superior_max_depth(file_path) is False and (self.contain_excluded_extensions(file_path) is False):
                    if file_path in self.synchronize_dict.keys():
                        if self.synchronize_dict[file_path].update_instance() == 1:
                            => self.ftp.remove_file(srv_full_path) # final
                            => self.ftp.file_transfer(path_file, srv_full_path, file_name) # final
                    else:
                        => self.ftp.file_transfer(path_file, srv_full_path, file_name) # final

    -> self.any_removals()
        for removed_path in path_removed_list:
            if removed_path not in self.to_remove_from_dict:
                # thread here
                if isinstance(self.synchronize_dict[removed_path], File):
                    => self.ftp.remove_file(srv_full_path) # final
                    self.to_remove_from_dict.append(removed_path) # need join
                elif isinstance(self.synchronize_dict[removed_path], Directory):
                    self.to_remove_from_dict.append(removed_path) # need join

                    -> self.remove_all_in_directory(removed_path, srv_full_path, path_removed_list)
                        for path in path_removed_list:
                            # generate sorted_containers
                        for i in range(len(sorted_containers)-1, -1, -1):
                            for to_delete in sorted_containers[i]:
                                # thread here
                                if isinstance(self.synchronize_dict[to_delete], File):
                                    => self.ftp.remove_file(to_delete_ftp) # final
                                    self.to_remove_from_dict.append(to_delete) # need join ?
                                else:
                                    -> # recursive call : need join ?
                        # join here ?
                        => self.ftp.remove_folder(srv_full_path) # final
                        self.to_remove_from_dict.append(removed_directory)
        # join here
        for to_remove in self.to_remove_from_dict:
            # clear dictionnary

    => self.ftp.disconnect() # final


regarder :
- aiofiles pour tenter envoi async
- aioinput pour guetter caractère de fin d'exécution
